<!-- Carlos Parrodi MartÃ­nez A01421454  -->
<!-- Juan Carlos Velazco A01326707  -->
<html>

<head>
    <title>DC Carnival</title>
    <style>
        canvas {
            width: 100%;
            height: 100%
        }

        p {
            position: absolute;
            display: block;
            z-index: 99;
            left: 2%;
            top: 2%;
            color: white
        }
    </style>
</head>

<body>
    <p>Instructions for the DC Carnival: <br>A = go left<br>D = go right<br>W = go up<br>S = go down<br>UP = go
        forward<br>Down = gobackwards<br>Left = rotate left<br>Right = rotate right<br>T/G = car Forward and Back
    <script src="three.min.js"> </script>
    <script src='https://mamboleoo.be/learnThree/demos/OBJLoader.js'></script>
    <script>
        window.addEventListener('keydown', doKeyDown, true);
        var cam_zpos = 480;
        var cam_xpos = -20.0;
        var cam_ypos = -5.0;
        var zpos = 2.0;
        var xpos = 0;
        var aug = 0;
        var augx = 0;
        var theta = 0;
        var velocity = 0.005;
        var velocity2 = 0;
        var increase = true;
        var heightOfSpinner = 0;
        var goUp = true;
        var goDown = true;
        var carouselrot = 0.005
        var carouselincrease = 0.05
        var hammerheadup = false
        var dolphinup = false
        var whaleup = false
        var sharkup = false
        var anglerup = true
        var numberOfTeeth = 10;

        var wheelrot = 0;
        var acc = 0.0
        var carOrientation = -3.1416/2;
        var moveForward = false;
        var moveBackward = false;
        var moveLeft = false;
        var moveRight = false;
        
        var dronefree = false
        var spikeout = false
        var spoilerout = false
        var shoot = false
        var spoilercount = 0
        var laserready = true

        function doKeyDown(evt) {
            console.log("Tecla presionada: " + evt.keyCode);
            switch (evt.keyCode) {
                case 38:
                    /* Up arrow was pressed */
                    aug -= 1;
                    break;
                case 40:
                    /* Down arrow was pressed */
                    aug += 1;
                    break;
                case 37:
                    /* Left arrow was pressed */
                    theta += 10 / 90;
                    break;
                case 39:
                    /* Right arrow was pressed */
                    theta -= 10 / 90;
                    break;
                case 65:
                    /* a was pressed */
                    augx -= 1;
                    break;
                case 68:
                    /* d was pressed */
                    augx += 1;
                    break;
                case 87:
                    /* w was pressed */
                    camera.position.y += 1;
                    break;
                case 83:
                    /* s was pressed */
                    camera.position.y -= 1;
                    break;
                case 78:
                    /* n was pressed */ //izq
                    moveLeft= true;
                    if (wheelrot < 32)
                        wheelrot += 2;
                    break;
                case 77:
                    /* m was pressed */ //der
                    moveRight = true;
                    if (wheelrot > -32)
                        wheelrot -= 2;
                    break;
                case 71:
                    /* g was pressed */ //move back
                    moveBackward = true;
                    if (acc < 2) {
                        if (acc < 0)
                            acc += 0.05
                        else acc += 0.01
                    }
                    break;
                case 84:
                    /* t was pressed */ //move forward
                    moveForward = true;
                    if (acc > -0.5) {
                        if (acc > 0)
                            acc -= 0.05
                        else acc -= 0.01
                    }
                    break;
                case 76:
                    /* l was pressed */
                    dronefree = !dronefree
                    break;
                case 90:
                    /* z was pressed */
                    spikeout = !spikeout
                    break;
                case 88:
                    /* x was pressed */
                    shoot = true
                    break;
                case 67:
                    /* c was pressed */
                    spoilerout = !spoilerout
                    break;
            }
        }
        // three basic components of a scene

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
        var renderer = new THREE.WebGLRenderer();

        //define the 'grass'
        var grass = new THREE.BoxGeometry(2900, 1, 1500);
        var loader = new THREE.TextureLoader();
        var textureMaterialGrass = new THREE.MeshLambertMaterial({
            map: loader.load("textures/grass.jpg")
        });
        var floor = new THREE.Mesh(grass, textureMaterialGrass);
        scene.add(floor);

        //create the carnival:
        var carnival = new THREE.Object3D();

        //create the ferry:
        var gondolasGroup = new THREE.Object3D();

        createRuedaDeLaFortuna(gondolasGroup);
        carnival.add(ferry);

        //create the flash game:
        var geometryForFlashGame = new THREE.Geometry();
        createFlashGame();
        carnival.add(gForceGame);


        createCarousel()
        carnival.add(carousel)


        carnival.position.x -= 110
        carnival.position.z = 250
        scene.add(carnival)

        var groupOfPyramids = new THREE.Object3D();
        generatorOfPyramids(1, 400);
        groupOfPyramids.position.z = 0;
        scene.add(groupOfPyramids)

        createRoad()
        scene.add(road)


        createCar()
        scene.add(car)


        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        camera.position.z = cam_zpos;
        camera.position.y = 25;
        camera.position.x = 0;

        var pointLight = new THREE.PointLight(0xFFFFFF);
        var pointLight2 = new THREE.PointLight(0xFFFFFF);
        var thesun = new THREE.PointLight(0xFFFFFF);
        pointLight.position.z += 10
        pointLight2.position.z += 10
        scene.add(thesun);
        thesun.position.y += 1000
        scene.add(pointLight);
        scene.add(pointLight2);
        renderer.setClearColor(0x00AAAA, 1);

        function generatorOfPyramids(numOfPyramids, startX) {
            //create pyramid
            var positionOnX = startX;
            for (var index = 0; index < numOfPyramids; index++) {
                //var numberOfLevel = 3 + Math.floor(Math.random() * 7)
                //var numberOfLength = 350 + Math.floor(Math.random() * 200)
                var numberOfLevel = 9
                var numberOfLength = 500
                console.log(numberOfLength)
                createPyramid(numberOfLevel, numberOfLength);
                pyramid.position.x += positionOnX
                groupOfPyramids.add(pyramid)
                positionOnX = positionOnX + numberOfLength * 2;
            }

        }

        function createCar() {
            var carmaterial = new THREE.MeshStandardMaterial({
                color: 0xed902f,
                roughness: 0,
                metalness: 0
            });
            car = new THREE.Object3D();
            var carloader = new THREE.OBJLoader();
            carloader.load(
                'models/CarBody.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = carmaterial;
                    });
                    car.add(object)
                    car.position.z = 400
                    car.position.y = 5
                    car.rotation.x = THREE.Math.degToRad(-90)
                    car.rotation.z = THREE.Math.degToRad(-90)


                }
            );
            carseat1 = new THREE.Object3D();
            var textureSeat = new THREE.MeshLambertMaterial({
                map: loader.load("textures/seat.png")
            });
            carloader.load(
                'models/Seat.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureSeat;
                    });
                    carseat1.add(object)
                    carseat1.position.z += 3
                    carseat1.position.y += 3
                    carseat1.position.x += 3
                    car.add(carseat1)
                }
            );
            carseat2 = new THREE.Object3D();
            carloader.load(
                'models/Seat.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureSeat;
                    });
                    carseat2.add(object)
                    carseat2.position.z += 3
                    carseat2.position.y += 3
                    carseat2.position.x -= 3
                    car.add(carseat2)
                }
            );
            stwheel = new THREE.Object3D();
            var textureStwheel = new THREE.MeshLambertMaterial({
                map: loader.load("textures/steering wheel.png")
            });
            carloader.load(
                'models/steering wheel.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureStwheel;
                    });
                    stwheel.add(object)
                    stwheel.position.z += 5.2
                    stwheel.position.x += 3.4
                    car.add(stwheel)
                }
            );
            sus = new THREE.Object3D();
            var textureSus = new THREE.MeshLambertMaterial({
                map: loader.load("textures/suspension.png")
            });
            carloader.load(
                'models/suspension.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureSus;
                    });
                    sus.add(object)
                    sus.position.y -= 10.5
                    car.add(sus)
                }
            );
            susback = new THREE.Object3D();
            carloader.load(
                'models/susback.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureSus;
                    });
                    susback.add(object)
                    susback.position.y += 8.5
                    susback.position.z += 0.5
                    car.add(susback)
                }
            );
            wheels = new THREE.Object3D();
            wheel1 = new THREE.Object3D();
            tire1 = new THREE.Object3D();
            var texturetire = new THREE.MeshLambertMaterial({
                map: loader.load("textures/tire.png")
            });
            carloader.load(
                'models/tire.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturetire;
                    });
                    tire1.add(object)
                    wheel1.add(tire1)
                }
            );
            rim1 = new THREE.Object3D();
            var texturerim = new THREE.MeshLambertMaterial({
                map: loader.load("textures/rim.png")
            });
            carloader.load(
                'models/rim.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturerim;
                    });
                    rim1.add(object)
                    wheel1.add(rim1)
                }
            );
            wheel1.position.z -= 3.51
            pivotw1 = new THREE.Object3D();
            pivotw1.position.y -= 13
            pivotw1.position.z += 1.515
            pivotw1.position.x += 8.5
            wheels.add(pivotw1)
            pivotw1.add(wheel1)

            wheel2 = new THREE.Object3D();
            tire2 = new THREE.Object3D();
            carloader.load(
                'models/tire.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturetire;
                    });
                    tire2.add(object)
                    wheel2.add(tire2)
                }
            );
            rim2 = new THREE.Object3D();
            carloader.load(
                'models/rim.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturerim;
                    });
                    rim2.add(object)
                    wheel2.add(rim2)
                }
            );
            wheel2.position.z -= 3.51
            pivotw2 = new THREE.Object3D();
            pivotw2.position.y -= 13
            pivotw2.position.z += 1.515
            pivotw2.position.x -= 8.5
            wheels.add(pivotw2)
            pivotw2.add(wheel2)

            wheel3 = new THREE.Object3D();
            tire3 = new THREE.Object3D();
            carloader.load(
                'models/tire.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturetire;
                    });
                    tire3.add(object)
                    wheel3.add(tire3)
                }
            );
            rim3 = new THREE.Object3D();
            carloader.load(
                'models/rim.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturerim;
                    });
                    rim3.add(object)
                    wheel3.add(rim3)
                }
            );
            wheel3.position.z -= 3.51
            pivotw3 = new THREE.Object3D();
            pivotw3.position.y += 10
            pivotw3.position.z += 1.515
            pivotw3.position.x += 8.57
            wheels.add(pivotw3)
            pivotw3.add(wheel3)

            wheel4 = new THREE.Object3D();
            tire4 = new THREE.Object3D();
            carloader.load(
                'models/tire.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturetire;
                    });
                    tire4.add(object)
                    wheel4.add(tire4)
                }
            );
            rim4 = new THREE.Object3D();
            carloader.load(
                'models/rim.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturerim;
                    });
                    rim4.add(object)
                    wheel4.add(rim4)
                }
            );
            wheel4.position.z -= 3.51
            wheel4.rotation.z = THREE.Math.degToRad(180)
            pivotw4 = new THREE.Object3D();
            pivotw4.position.y += 10
            pivotw4.position.z += 1.515
            pivotw4.position.x -= 8.57
            wheels.add(pivotw4)
            pivotw4.add(wheel4)

            car.add(wheels)

            exhaust = new THREE.Object3D();
            carloader.load(
                'models/exhaust.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureSus;
                    });
                    exhaust.add(object)
                    exhaust.position.y += 13
                    exhaust.position.z += 4
                    car.add(exhaust)
                }
            );
            shift = new THREE.Object3D();
            var textureshift = new THREE.MeshLambertMaterial({
                map: loader.load("textures/shift.png")
            });
            carloader.load(
                'models/shift.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureshift;
                    });
                    shift.add(object)
                    shift.position.z += 3
                    shift.position.y += 0.5
                    car.add(shift)
                }
            );
            lights = new THREE.Object3D();
            var texturelights = new THREE.MeshLambertMaterial({
                map: loader.load("textures/lights.png")
            });
            carloader.load(
                'models/lights.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturelights;
                    });
                    lights.add(object)
                    lights.position.y -= 13
                    lights.position.z += 4
                    car.add(lights)
                }
            );
            var planegeom = new THREE.PlaneGeometry(11.5, 3.5)
            var glass = new THREE.MeshBasicMaterial({
                color: 0x00FFFF,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            var window = new THREE.Mesh(planegeom, glass)
            window.position.z += 8
            window.position.y -= 2.1
            window.rotation.x = THREE.Math.degToRad(68)
            car.add(window)

            gun = new THREE.Object3D();
            lasergeom = new THREE.CylinderGeometry(20,20,200,32)
            lasermaterial = new THREE.MeshBasicMaterial( {color: 0xB22222} );
            laser = new THREE.Mesh(lasergeom,lasermaterial)
            gun.add(laser)
            laser.position.z +=200

            var texturegun = new THREE.MeshLambertMaterial({
                map: loader.load("textures/gun.png")
            });
            carloader.load(
                'models/Gun.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturegun;
                    });
                    gun.add(object)
                    gun.position.z += 5.5
                    gun.position.y -= 6
                    gun.scale.set(0.01, 0.01, 0.01)
                    
                    car.add(gun)
                    
                }
            );
            
            spoiler = new THREE.Object3D();
            var texturespoiler = new THREE.MeshLambertMaterial({
                map: loader.load("textures/spoiler.png")
            });
            carloader.load(
                'models/Spoiler.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturespoiler;
                    });
                    spoiler.add(object)
                    spoiler.position.y += 14
                    spoiler.position.z += 6
                    car.add(spoiler)
                }
            );
            var texturespike = new THREE.MeshLambertMaterial({
                map: loader.load("textures/spike.png")
            });
            spike = new THREE.Object3D();
            carloader.load(
                'models/Spike.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturespike;
                    });
                    spike.add(object)

                    spike.scale.set(0.02, 0.02, 0.02)
                    spike.position.y -= 6
                    spike.position.z += 2.5
                    spike.rotation.x = THREE.Math.degToRad(90)
                    car.add(spike)
                }
            );

            var texturedrone = new THREE.MeshLambertMaterial({
                map: loader.load("textures/drone.png")
            });
            drone = new THREE.Object3D();
            carloader.load(
                'models/Drone.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturedrone;
                    });
                    drone.add(object)
                    drone.scale.set(0.0012, 0.0012, 0.0012)
                    drone.rotation.x = THREE.Math.degToRad(-10)
                    drone.position.y += 9.5
                    drone.position.z += 7

                }
            );
            var texturehelix = new THREE.MeshLambertMaterial({
                map: loader.load("textures/helix.png")
            });
            helix = new THREE.Object3D();
            helix1 = new THREE.Object3D();
            pivot1 = new THREE.Object3D();
            pivot1.position.y += 11.65
            pivot1.position.z += 8.5
            pivot1.position.x += 0.1
            carloader.load(
                'models/helix.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturehelix;
                    });
                    helix1.add(object)
                    helix1.scale.set(0.0012, 0.0012, 0.0012)
                    helix1.rotation.x = THREE.Math.degToRad(-10)
                    helix1.position.y -= 2.14
                    helix1.position.z -= 1.5
                    helix1.position.x -= 0.1
                    pivot1.add(helix1)
                    helix.add(pivot1)
                }
            );


            helix2 = new THREE.Object3D();
            pivot2 = new THREE.Object3D();
            pivot2.position.y += 7.89
            pivot2.position.z += 8.95
            pivot2.position.x += 2.65
            carloader.load(
                'models/helix.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturehelix;
                    });
                    helix2.add(object)
                    helix2.scale.set(0.0012, 0.0012, 0.0012)
                    helix2.rotation.x = THREE.Math.degToRad(-10)
                    helix2.position.y -= 2.125
                    helix2.position.z -= 1.5
                    helix2.position.x -= 0.1
                    pivot2.add(helix2)
                    helix.add(pivot2)
                }
            );
            helix3 = new THREE.Object3D();
            pivot3 = new THREE.Object3D();
            pivot3.position.y += 7.89
            pivot3.position.z += 8.95
            pivot3.position.x -= 2.45
            carloader.load(
                'models/helix.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = texturehelix;
                    });
                    helix3.add(object)
                    helix3.scale.set(0.0012, 0.0012, 0.0012)
                    helix3.rotation.x = THREE.Math.degToRad(-10)
                    helix3.position.y -= 2.125
                    helix3.position.z -= 1.5
                    helix3.position.x -= 0.1
                    pivot3.add(helix3)
                    helix.add(pivot3)
                }
            );
            helix.add(drone)
            car.add(helix)
        }

        function createRoad() {
            road = new THREE.Object3D()
            var textureRoad = new THREE.MeshLambertMaterial({
                map: loader.load("textures/road.jpg")
            });
            var geomRoadFirstLine = new THREE.BoxGeometry(45, 6, 45);
            for (var xPos = -2500; xPos < 2500; xPos += 45) {
                var roadFirstLine = new THREE.Mesh(geomRoadFirstLine, textureRoad);
                roadFirstLine.position.z = 400
                roadFirstLine.position.x = xPos
                road.add(roadFirstLine)
            }
        }

        //Create the Pyramid
        function createPyramid(levels, length, positionX) {
            //colors:
            var textureBrick = new THREE.MeshLambertMaterial({
                map: loader.load("textures/wall.png")
            });
            var textureBrick1 = new THREE.MeshLambertMaterial({
                map: loader.load("textures/smalWall.png")
            });
            var textureBrick2 = new THREE.MeshLambertMaterial({
                map: loader.load("textures/wallLarge.png")
            });
            var textureBrick3 = new THREE.MeshLambertMaterial({
                map: loader.load("textures/stairs.png")
            });
            //pyramid geom and groups:
            pyramid = new THREE.Object3D();
            //the pyramid will be divided in 2 main sections: 
            var pyramidBase = new THREE.Object3D();
            var pyramidTop = new THREE.Object3D();
            var groupSteps = new THREE.Object3D();
            var pyramidStairs = new THREE.Object3D();
            var heightOfEachLevel = length * 0.08
            var distanceToreduceEachLevel = length * 0.5 / levels
            var increaseY = 0
            var startOfStepsY = -18
            var startOfStepsZ = 350
            var startOfStepsX = 500

            //start of the 9 levels of the pyramid
            for (var i = 0; i < levels; i++) {
                //angle
                var topOfBase = length * .95;
                var geometryBase = new THREE.CylinderBufferGeometry(topOfBase, length, heightOfEachLevel, 4);
                var base1 = new THREE.Mesh(geometryBase, textureBrick);
                base1.position.y += increaseY;
                increaseY += heightOfEachLevel
                pyramidBase.add(base1)
                length = topOfBase - distanceToreduceEachLevel
            }
            //last floor level
            var geomSidesTop = new THREE.BoxGeometry(60, 70, 60);
            var sideTop1 = new THREE.Mesh(geomSidesTop, textureBrick1);
            sideTop1.position.x -= 42
            sideTop1.position.z += 42
            pyramidTop.add(sideTop1)
            var sideTop2 = new THREE.Mesh(geomSidesTop, textureBrick1);
            sideTop2.position.x += 42
            sideTop2.position.z += 42
            pyramidTop.add(sideTop2)
            var sideTop3 = new THREE.Mesh(geomSidesTop, textureBrick1);
            sideTop3.position.x += 42
            sideTop3.position.z -= 42
            pyramidTop.add(sideTop3)
            var sideTop4 = new THREE.Mesh(geomSidesTop, textureBrick1);
            sideTop4.position.x -= 42
            sideTop4.position.z -= 42
            pyramidTop.add(sideTop4)
            var geomTop = new THREE.BoxGeometry(142, 30, 142);
            var geomTop2 = new THREE.BoxGeometry(130, 20, 130);
            var mainTop1 = new THREE.Mesh(geomTop, textureBrick1);
            mainTop1.position.y += 49
            pyramidTop.add(mainTop1)
            var mainTop3 = new THREE.Mesh(geomTop, textureBrick1);
            mainTop3.position.y += 90
            pyramidTop.add(mainTop3)
            var mainTop2 = new THREE.Mesh(geomTop2, textureBrick1);
            mainTop2.position.y += 70
            pyramidTop.add(mainTop2)
            pyramidTop.position.y = 350

            //stairs sides FRONT
            var frontSides = new THREE.Object3D();
            var geometryStairsSideFB = new THREE.BoxGeometry(40, 475, 15);
            var geometryStairsSideLR = new THREE.BoxGeometry(15, 475, 40);
            var frontSideStairs1 = new THREE.Mesh(geometryStairsSideFB, textureBrick2);
            frontSides.add(frontSideStairs1)
            var frontSideStairs2 = new THREE.Mesh(geometryStairsSideFB, textureBrick2);
            frontSides.add(frontSideStairs2)
            frontSides.position.y += 145
            frontSides.position.z = 235
            frontSides.position.x -= 60
            frontSideStairs2.position.x += 120
            frontSides.rotation.x = -0.65
            pyramidStairs.add(frontSides)
            //stairs steps:
            startOfStepsY = -18
            startOfStepsZ = 353
            for (var j = 0; j < 8 * levels; j++) {
                var geomSteps = new THREE.BoxGeometry(80, 5, 30)
                var steps1 = new THREE.Mesh(geomSteps, textureBrick3)
                steps1.position.z = startOfStepsZ
                steps1.position.y = startOfStepsY
                groupSteps.add(steps1)
                startOfStepsY += 5
                startOfStepsZ -= 3.8
            }

            //stairs sides BACK
            var backSides = new THREE.Object3D();
            var backSideStairs1 = new THREE.Mesh(geometryStairsSideFB, textureBrick2);
            backSides.add(backSideStairs1)
            var backSideStairs2 = new THREE.Mesh(geometryStairsSideFB, textureBrick2);
            backSides.add(backSideStairs2)
            backSides.position.y += 145
            backSides.position.z = -235
            backSides.position.x -= 60
            backSideStairs2.position.x += 120
            backSides.rotation.x = 0.65
            pyramidStairs.add(backSides)
            //stairs steps:
            startOfStepsY = -18
            startOfStepsZ = -353
            for (var j = 0; j < 8 * levels; j++) {
                var geomSteps = new THREE.BoxGeometry(120, 5, 30)
                var steps1 = new THREE.Mesh(geomSteps, textureBrick3)
                steps1.position.z = startOfStepsZ
                steps1.position.y = startOfStepsY
                groupSteps.add(steps1)
                startOfStepsY += 5
                startOfStepsZ += 3.8
            }

            //stairs sides LEFT
            var leftSides = new THREE.Object3D();
            var leftSideStairs1 = new THREE.Mesh(geometryStairsSideLR, textureBrick2);
            leftSides.add(leftSideStairs1)
            var leftSideStairs2 = new THREE.Mesh(geometryStairsSideLR, textureBrick2);
            leftSides.add(leftSideStairs2)
            leftSides.position.y += 145
            leftSides.position.z = -60
            leftSides.position.x -= 232
            leftSideStairs2.position.z += 120
            leftSides.rotation.z = -0.65
            pyramidStairs.add(leftSides)
            //stairs steps:
            startOfStepsX = -350
            startOfStepsY = -18
            for (var j = 0; j < 8 * levels; j++) {
                var geomSteps = new THREE.BoxGeometry(30, 5, 120)
                var steps1 = new THREE.Mesh(geomSteps, textureBrick3)
                steps1.position.x = startOfStepsX
                steps1.position.y = startOfStepsY
                groupSteps.add(steps1)
                startOfStepsY += 5
                startOfStepsX += 3.8
            }

            //stairs sides RIGHT
            var rightSides = new THREE.Object3D();
            var rightSideStairs1 = new THREE.Mesh(geometryStairsSideLR, textureBrick2);
            rightSides.add(rightSideStairs1)
            var rightSideStairs2 = new THREE.Mesh(geometryStairsSideLR, textureBrick2);
            rightSides.add(rightSideStairs2)
            rightSides.position.y += 145
            rightSides.position.z = -60
            rightSides.position.x += 232
            rightSideStairs2.position.z += 120
            rightSides.rotation.z = 0.65
            pyramidStairs.add(rightSides)
            //stairs steps:
            startOfStepsX = 350
            startOfStepsY = -18
            for (var j = 0; j < 8 * levels; j++) {
                var geomSteps = new THREE.BoxGeometry(30, 5, 120)
                var steps1 = new THREE.Mesh(geomSteps, textureBrick3)
                steps1.position.x = startOfStepsX
                steps1.position.y = startOfStepsY
                groupSteps.add(steps1)
                startOfStepsY += 5
                startOfStepsX -= 3.8
            }




            pyramid.position.y = 10
            pyramid.position.x += 140
            pyramidBase.rotation.y += 0.8

            pyramid.add(groupSteps)
            pyramid.add(pyramidBase)
            pyramid.add(pyramidStairs)
            pyramid.add(pyramidTop)
        }

        function createCarousel() {
            //Create Carousel Game
            var materialcarouseltop = new THREE.MeshStandardMaterial({
                color: 0x006400,
                emissive: 0x505050,
                roughness: 0.6,
                metalness: 1,
            });
            var materialcarouselbaseorange = new THREE.MeshStandardMaterial({
                color: 0x9E4801,
                emissive: 0x505050,
                roughness: 0.6,
                metalness: 0.5,
            });
            var materialcarouselbaseblue = new THREE.MeshStandardMaterial({
                color: 0x3E47CB,
                emissive: 0x505050,
                roughness: 0.6,
                metalness: 0,
            });
            var textureMaterialGold = new THREE.MeshLambertMaterial({
                map: loader.load("textures/gold.jpg")
            });
            var carouselloader = new THREE.OBJLoader();
            var textureLoaderCarousel = new THREE.TextureLoader();
            var fishgroup = new THREE.Object3D()
            carousel = new THREE.Object3D()
            var carouselmidpolegeom = new THREE.CylinderGeometry(5, 5, 60, 32)
            var carouseltopgeom = new THREE.ConeGeometry(60, 40, 60)
            var carouselbase1geom = new THREE.CylinderGeometry(60, 60, 5, 32)
            var carouselbase2geom = new THREE.CylinderGeometry(55, 55, 3, 32)
            var carouselpolegeom = new THREE.CylinderGeometry(1, 1, 60, 32)
            var carouseltop = new THREE.Mesh(carouseltopgeom, materialcarouseltop)
            var carouseltopbase = new THREE.Mesh(carouselbase2geom, materialcarouselbaseblue)
            var carouselbase1 = new THREE.Mesh(carouselbase1geom, materialcarouselbaseorange)
            var carouselbase2 = new THREE.Mesh(carouselbase2geom, materialcarouselbaseblue)
            var carouselmidpole = new THREE.Mesh(carouselmidpolegeom, materialcarouselbaseorange)
            var carouselpole1 = new THREE.Mesh(carouselpolegeom, textureMaterialGold)
            var carouselpole2 = new THREE.Mesh(carouselpolegeom, textureMaterialGold)
            var carouselpole3 = new THREE.Mesh(carouselpolegeom, textureMaterialGold)
            var carouselpole4 = new THREE.Mesh(carouselpolegeom, textureMaterialGold)
            var carouselpole5 = new THREE.Mesh(carouselpolegeom, textureMaterialGold)
            carouseltop.position.y += 45
            carouseltopbase.position.y += 23.5

            carouselbase1.position.y -= 30
            carouselbase2.position.y -= 28

            carouselpole1.position.x += 50
            carouselpole2.position.x += 15.45
            carouselpole2.position.z += 47.55
            carouselpole3.position.x -= 40.45
            carouselpole3.position.z += 29.38
            carouselpole4.position.x -= 40.45
            carouselpole4.position.z -= 29.38
            carouselpole5.position.x += 15.45
            carouselpole5.position.z -= 47.55

            carousel.add(carouseltop)
            carousel.add(carouseltopbase)
            carousel.add(carouselbase1)
            carousel.add(carouselbase2)
            carousel.add(carouselmidpole)
            carousel.add(carouselpole1)
            carousel.add(carouselpole2)
            carousel.add(carouselpole3)
            carousel.add(carouselpole4)
            carousel.add(carouselpole5)

            trident = new THREE.Object3D();
            carouselloader.load(
                'models/Trident.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureMaterialGold;
                    });
                    trident.add(object)
                    trident.scale.set(0.25, 0.1, 0.25)
                    trident.rotation.z = THREE.Math.degToRad(-90)
                    trident.rotation.y = THREE.Math.degToRad(-90)
                    trident.position.x = 40.4
                    trident.position.z += 1
                    carousel.add(trident)

                }
            );
            shark = new THREE.Object3D();
            var textureShark = new THREE.MeshLambertMaterial({
                map: loader.load("textures/shark.png")
            });
            carouselloader.load(
                'models/Shark.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureShark;
                    });
                    shark.add(object)
                    shark.scale.set(0.004, 0.004, 0.004)
                    shark.rotation.x = THREE.Math.degToRad(-90)
                    shark.rotation.z = THREE.Math.degToRad(30)
                    shark.position.x -= 41.45
                    shark.position.y = -20
                    shark.position.z += 25
                    fishgroup.add(shark)

                }
            );
            angler = new THREE.Object3D();
            var textureAngler = new THREE.MeshLambertMaterial({
                map: loader.load("textures/anglerfishpng.png")
            });
            carouselloader.load(
                'models/Angler fish.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureAngler;
                    });
                    angler.add(object)
                    angler.scale.set(0.12, 0.12, 0.12)
                    angler.rotation.x = THREE.Math.degToRad(-90)
                    angler.rotation.z = THREE.Math.degToRad(110)
                    angler.position.x += 15.45
                    angler.position.y = -25
                    angler.position.z += 47.55
                    fishgroup.add(angler)

                }
            );
            hammerhead = new THREE.Object3D();
            var textureHammerhead = new THREE.MeshLambertMaterial({
                map: loader.load("textures/hammerhead.png")
            });
            carouselloader.load(
                'models/Hammerhead.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureHammerhead;
                    });
                    hammerhead.add(object)
                    hammerhead.scale.set(0.015, 0.015, 0.015)
                    hammerhead.rotation.x = THREE.Math.degToRad(-90)
                    hammerhead.rotation.z = THREE.Math.degToRad(180)
                    hammerhead.position.x += 50
                    hammerhead.position.y = -7
                    hammerhead.position.z += 15
                    fishgroup.add(hammerhead)

                }
            );
            dolphin = new THREE.Object3D();
            var textureDolphin = new THREE.MeshLambertMaterial({
                map: loader.load("textures/dolphin.png")
            });
            carouselloader.load(
                'models/Dolphin.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureDolphin;
                    });
                    dolphin.add(object)
                    dolphin.scale.set(0.6, 0.6, 0.6)
                    dolphin.rotation.x = THREE.Math.degToRad(-94)
                    dolphin.rotation.y = THREE.Math.degToRad(-20)
                    dolphin.rotation.z = THREE.Math.degToRad(250)
                    dolphin.position.x += 27
                    dolphin.position.y = -20
                    dolphin.position.z -= 45
                    fishgroup.add(dolphin)

                }
            );
            whale = new THREE.Object3D();
            var textureWhale = new THREE.MeshLambertMaterial({
                map: loader.load("textures/whale.png")
            });
            carouselloader.load(
                'models/Whale.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = textureWhale;
                    });
                    whale.add(object)
                    whale.scale.set(0.02, 0.02, 0.02)
                    whale.rotation.x = THREE.Math.degToRad(-90)
                    whale.rotation.z = THREE.Math.degToRad(320)
                    whale.position.x -= 38
                    whale.position.y = -18
                    whale.position.z -= 32
                    fishgroup.add(whale)

                }
            );
            carousel.add(fishgroup)
            carousel.position.x = 150
            carousel.position.y = 30

        }


        //THE FLASH
        function createFlashGame() {
            gForceGame = new THREE.Object3D();
            //floor of the game:
            var robotRed = new THREE.MeshStandardMaterial({
                color: 0xC0C0C0,
                roughness: 0.6,
                metalness: 0.5,
            });
            var robotSilver = new THREE.MeshStandardMaterial({
                color: 0xFF0000,
                roughness: 0.6,
                metalness: 0.5,
            });
            var robotYellow = new THREE.MeshStandardMaterial({
                color: 0xBBBB00,
                roughness: 0.6,
                metalness: 0.5,
            });
            var loader2 = new THREE.TextureLoader();
            var textureFlash = new THREE.MeshLambertMaterial({
                map: loader2.load("textures/flash.jpg")
            });
            var baseOfGame = new THREE.Object3D();
            var geomOfBase = new THREE.CylinderGeometry(10, 11, 5, 32);
            var floorGame = new THREE.Mesh(geomOfBase, robotRed);
            baseOfGame.add(floorGame);
            var geomOfBase4 = new THREE.CylinderGeometry(85, 85, 0, 32);
            var floorGame4 = new THREE.Mesh(geomOfBase4, textureFlash);
            floorGame4.position.y = 1;
            baseOfGame.add(floorGame4);
            gForceGame.add(baseOfGame);
            var geomGearCenterGeom = new THREE.Geometry();
            createGear(0, 3, 100, geomGearCenterGeom, 3 / 4, 0, baseOfGame);
            geomGearCenterGeom.computeFaceNormals();
            centerGearForBall = new THREE.Mesh(geomGearCenterGeom, robotYellow);
            centerGearForBall.position.y = 60;
            centerGearForBall.rotation.x = 1.55;
            baseOfGame.add(centerGearForBall);
            var geometryBall = new THREE.SphereGeometry(8, 32, 32);
            var redBall = new THREE.Mesh(geometryBall, robotSilver);
            redBall.position.y = 160;
            gForceGame.add(redBall);
            gForceGame.add(baseOfGame);
            //spinner
            spinner = new THREE.Object3D();
            var geomSpinner1 = new THREE.CylinderGeometry(3.5, 5, 45, 32);
            var spinner1 = new THREE.Mesh(geomSpinner1, robotRed);
            spinner1.position.y = 13;
            spinner1.rotation.z -= 1.55;
            spinner1.position.x = 22;
            spinner.add(spinner1);
            var geomSpinner2 = new THREE.CylinderGeometry(3.5, 5, 45, 32);
            var spinner2 = new THREE.Mesh(geomSpinner2, robotRed);
            spinner2.position.y = 13;
            spinner2.rotation.z += 1.55;
            spinner2.position.x = -22;
            spinner.add(spinner2);
            var geomOfCenter = new THREE.CylinderGeometry(5, 5, 10, 32);
            var centerOfSpinner = new THREE.Mesh(geomOfCenter, robotRed)
            centerOfSpinner.position.y = 13;
            spinner.add(centerOfSpinner)
            //spinner section of cabin:
            var loader = new THREE.OBJLoader();
            var cabin1 = new THREE.Object3D();
            var cabin2 = new THREE.Object3D();
            var textureLoader = new THREE.TextureLoader();
            var map = textureLoader.load('textures/texturePlane.png');
            var material = new THREE.MeshPhongMaterial({
                map: map
            });
            loader.load(
                'models/SpaceShuttle.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = material;
                    });
                    //cabin1.add(object)
                    cabin2.add(object)
                }
            );

            loader.load(
                'models/SpaceShuttle.obj ',
                function (object) {
                    object.traverse(function (node) {
                        if (node.isMesh) node.material = material;
                    });
                    //cabin1.add(object)
                    cabin1.add(object)
                }
            );
            cabin1.scale.set(0.15, 0.15, 0.15)
            cabin2.scale.set(0.15, 0.15, 0.15)
            cabin1.rotation.x = THREE.Math.degToRad(90)
            cabin1.rotation.y = THREE.Math.degToRad(180)
            cabin2.rotation.x = THREE.Math.degToRad(-90)
            cabin1.position.y = 7;
            cabin1.position.x = 50;
            spinner.add(cabin1);
            cabin2.position.y = 7;
            cabin2.position.x = -50;
            spinner.add(cabin2);
            gForceGame.add(spinner);
            gForceGame.position.x = -20;

        }

        //THE JOKER
        function createRuedaDeLaFortuna(gondolasGroup) {
            ferry = new THREE.Object3D();
            //floor of ferry
            var robotmaterialbase = new THREE.MeshStandardMaterial({
                color: 0xFF4500,
                roughness: 0.5,
                metalness: 0.5,
            });
            var ferryFloor = new THREE.Object3D();
            var floorOfFerryGeo = new THREE.BoxGeometry(90, 10, 40);
            var floorFerry = new THREE.Mesh(floorOfFerryGeo, robotmaterialbase);
            ferryFloor.add(floorFerry);
            var stairs1Geo = new THREE.BoxGeometry(20, 1, 40);
            var stairs1 = new THREE.Mesh(stairs1Geo, robotmaterialbase);
            stairs1.position.z += 20;
            stairs1.position.y += 1;
            ferryFloor.add(stairs1);
            var stairs2Geo = new THREE.BoxGeometry(20, 1, 40);
            var stairs2 = new THREE.Mesh(stairs2Geo, robotmaterialbase);
            stairs2.position.z += 15;
            stairs2.position.y += 2;
            ferryFloor.add(stairs2);
            var stairs3Geo = new THREE.BoxGeometry(20, 1, 40);
            var stairs3 = new THREE.Mesh(stairs3Geo, robotmaterialbase);
            stairs3.position.z += 10;
            stairs3.position.y += 3;
            ferryFloor.add(stairs3);
            ferry.add(ferryFloor);
            //base
            var robotmaterialtubes = new THREE.MeshStandardMaterial({
                color: 0x8000BB,
                roughness: 0.6,
                metalness: 0.5,
            });
            var baseTubes = new THREE.Object3D();
            var geometryTubesBase1 = new THREE.CylinderGeometry(3, 3, 80, 32);
            var cylinderBase1 = new THREE.Mesh(geometryTubesBase1, robotmaterialtubes);
            cylinderBase1.position.x = -25;
            cylinderBase1.position.z = 15;
            cylinderBase1.position.y = 30;
            cylinderBase1.rotation.z -= .5;
            baseTubes.add(cylinderBase1);
            var geometryTubesBase2 = new THREE.CylinderGeometry(3, 3, 80, 32);
            var cylinderBase2 = new THREE.Mesh(geometryTubesBase2, robotmaterialtubes);
            cylinderBase2.position.x = -25;
            cylinderBase2.position.z = -15;
            cylinderBase2.position.y = 30;
            cylinderBase2.rotation.z -= .5;
            baseTubes.add(cylinderBase2);
            var geometryTubesBase3 = new THREE.CylinderGeometry(3, 3, 80, 32);
            var cylinderBase3 = new THREE.Mesh(geometryTubesBase3, robotmaterialtubes);
            cylinderBase3.position.x = 25;
            cylinderBase3.position.z = 15;
            cylinderBase3.position.y = 30;
            cylinderBase3.rotation.z += .5;
            baseTubes.add(cylinderBase3);
            var geometryTubesBase4 = new THREE.CylinderGeometry(3, 3, 80, 32);
            var cylinderBase4 = new THREE.Mesh(geometryTubesBase4, robotmaterialtubes);
            cylinderBase4.position.x = 25;
            cylinderBase4.position.z = -15;
            cylinderBase4.position.y = 30;
            cylinderBase4.rotation.z += .5;
            baseTubes.add(cylinderBase4);
            ferry.add(baseTubes);
            //add center of the whell
            var ferryCenter = new THREE.Object3D();
            var robotmaterialcenter = new THREE.MeshStandardMaterial({
                color: 0x55BB00,
                roughness: 0.6,
                metalness: 0.5,
            });
            var textureMaterial1 = new THREE.MeshLambertMaterial({
                map: loader.load("textures/joker1.jpg")
            });
            var geometryCenterFerry1 = new THREE.CylinderGeometry(10, 15, 5, 32);
            var cylinderCenter1 = new THREE.Mesh(geometryCenterFerry1, robotmaterialcenter);
            cylinderCenter1.position.y = 73;
            cylinderCenter1.position.z = 15;
            cylinderCenter1.rotation.x += 1.6;
            ferryCenter.add(cylinderCenter1);
            var geometryCenterFerry2 = new THREE.CylinderGeometry(15, 10, 5, 32);
            var cylinderCenter2 = new THREE.Mesh(geometryCenterFerry2, robotmaterialcenter);
            cylinderCenter2.position.y = 73;
            cylinderCenter2.position.z = -15;
            cylinderCenter2.rotation.x += 1.6;
            ferryCenter.add(cylinderCenter2);
            ferry.add(ferryCenter);
            var geometryCenterFerryMain = new THREE.CylinderGeometry(10, 10, 2, 32);
            var cylinderCenterMain = new THREE.Mesh(geometryCenterFerryMain, textureMaterial1);
            cylinderCenterMain.position.y = 73;
            cylinderCenterMain.position.z = 17;
            cylinderCenterMain.rotation.x += 1.6;
            cylinderCenterMain.rotation.y -= 1.6;
            ferryCenter.add(cylinderCenterMain);
            //CENTER GEAR
            var centerColorMetalOrange = new THREE.MeshLambertMaterial({
                color: 0xFF4500,
                roughness: 0.6,
                metalness: 0.5,
            });
            var centerColorMetalPurple = new THREE.MeshStandardMaterial({
                color: 0x8000BB,
                roughness: 0.6,
                metalness: 0.5,
            });

            var geomGearCenterGeomIntern = new THREE.Geometry();
            createGear(0, 4, 12, geomGearCenterGeomIntern, 4 / 6, 0, gondolasGroup);
            geomGearCenterGeomIntern.computeFaceNormals();
            centerInternGear = new THREE.Mesh(geomGearCenterGeomIntern, centerColorMetalPurple);
            centerInternGear.position.y = 73;
            ferry.add(centerInternGear);
            var geomGearCenterGeom = new THREE.Geometry();
            createGear(4, 8, 2, geomGearCenterGeom, 50, 1, gondolasGroup);
            geomGearCenterGeom.computeFaceNormals();
            centerGear = new THREE.Mesh(geomGearCenterGeom, centerColorMetalOrange);
            centerGear.position.y = 73;
            centerGear.position.z = 9;
            ferry.add(centerGear);
            var geomGearCenterGeom2 = new THREE.Geometry();
            createGear(4, 8, 2, geomGearCenterGeom2, 50, 0, gondolasGroup);
            geomGearCenterGeom2.computeFaceNormals();
            centerGear2 = new THREE.Mesh(geomGearCenterGeom2, centerColorMetalOrange);
            centerGear2.position.y = 73;
            centerGear2.position.z = -9;
            ferry.add(centerGear2);
            //Gondolas:
            gondolasGroup.position.y = 73;
            ferry.add(gondolasGroup);
            ferry.position.x = -200;
            ferry.position.z = 20

        }


        //initialCounterOfVertices -> index inciial de zona de vertices de la dona de enfrente(pares para inner circle e impares para circulo exterior)
        //initialCounterOfVertices2 -> index inciial de zona de vertices de la dona de atras(pares para inner circle e impares para circulo exterior)
        //counterOfVerticesFrontTeeth -> index inicial de la zona de vertices de las puntas de los dientes exteriores de enfrente(tods corridos)
        //counterOfVerticesBackTeeth -> index inicial de la zona de vertices de las puntas de los dientes exteriores de atras(tods corridos)
        //counterOfVerticesInnerFrontTeeth -> index inicial de la zona de vertices de las puntas de los dientes interiores de enfrente (tods corridos)
        //counterOfVerticesInnerBackTeeth -> index inicial de la zona de vertices de las puntas de los dientes interiores de atras (tods corridos)
        function createGear(innerRadio, externalRadio, centerZ, geometry, lengthExternalTeeth, yesOrNo, gondolasGroup) {
            //create the circular body:
            //each iteration creates the vertices of a "line" of the circle
            //the vertices of each line are: inner circle, bigger circle
            //after the second iteration the program start to join the 2 vertices that is creating with the ones of the before iteration
            //front circle
            var currentAngle = 0;
            var incrementAngle = 360 / (numberOfTeeth * 2);
            var initialCounterOfVertices = geometry.vertices.length;
            var adjustmentangle = -incrementAngle * 0.2;
            var inneradjustmentangle = -incrementAngle * 0.1;
            adjustmentangle = adjustmentangle * -1;
            for (var i = 1; i <= numberOfTeeth * 4; i++) {
                adjustmentangle = adjustmentangle * -1;
                inneradjustmentangle = inneradjustmentangle * -1;
                var innerVertice1x = innerRadio * Math.cos(THREE.Math.degToRad(currentAngle + inneradjustmentangle));
                var innerVertice1y = innerRadio * Math.sin(THREE.Math.degToRad(currentAngle + inneradjustmentangle));
                var externalVertice1x = externalRadio * Math.cos(THREE.Math.degToRad(currentAngle + adjustmentangle));
                var externalVertice1y = externalRadio * Math.sin(THREE.Math.degToRad(currentAngle + adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(innerVertice1x, innerVertice1y, centerZ));
                geometry.vertices.push(new THREE.Vector3(externalVertice1x, externalVertice1y, centerZ));
                //join with the two before points
                if (i > 1) {
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices + i, initialCounterOfVertices + i - 2,
                        initialCounterOfVertices + i - 1));
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices + i, initialCounterOfVertices + i - 1,
                        initialCounterOfVertices + i + 1));
                }
                currentAngle += incrementAngle;
            }

            //back circle
            var currentAngle = 0;
            var incrementAngle = 360 / (numberOfTeeth * 2);
            var initialCounterOfVertices2 = geometry.vertices.length;

            for (var i = 1; i <= numberOfTeeth * 4; i++) {
                adjustmentangle = adjustmentangle * -1;
                inneradjustmentangle = inneradjustmentangle * -1;
                var innerVertice1x = innerRadio * Math.cos(THREE.Math.degToRad(currentAngle + inneradjustmentangle));
                var innerVertice1y = innerRadio * Math.sin(THREE.Math.degToRad(currentAngle + inneradjustmentangle));
                var externalVertice1x = externalRadio * Math.cos(THREE.Math.degToRad(currentAngle + adjustmentangle));
                var externalVertice1y = externalRadio * Math.sin(THREE.Math.degToRad(currentAngle + adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(innerVertice1x, innerVertice1y, -centerZ));
                geometry.vertices.push(new THREE.Vector3(externalVertice1x, externalVertice1y, -centerZ));

                //join with the two before points
                if (i > 1) {
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + i, initialCounterOfVertices2 + i -
                        1, initialCounterOfVertices2 + i - 2));
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + i, initialCounterOfVertices2 + i +
                        1, initialCounterOfVertices2 + i - 1));
                }
                currentAngle += incrementAngle;
            }

            //add external teeth to the vertices array and faces:
            currentAngle = 0;
            var flagPutTeeth = false;
            var externalHeightTeeth = lengthExternalTeeth;
            var adjustmentangle = -lengthExternalTeeth * 0.2;
            //remember of when my new vertices that i will add will be:
            var counterOfVerticesFrontTeeth = geometry.vertices.length - 1;
            for (var i = 1; i <= numberOfTeeth * 4; i++) {

                adjustmentangle = adjustmentangle * -1;
                var externalTeethX1 = (externalRadio + externalHeightTeeth) * Math.cos(THREE.Math.degToRad(
                    currentAngle + adjustmentangle));
                var externalTeethY1 = (externalRadio + externalHeightTeeth) * Math.sin(THREE.Math.degToRad(
                    currentAngle + adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(externalTeethX1, externalTeethY1, centerZ));

                if (i != 1 && flagPutTeeth) {
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices + (i + (i - 1)),
                        initialCounterOfVertices + (i + (i - 1)) - 2, i + counterOfVerticesFrontTeeth));
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices + (i + (i - 1)) - 2, (i +
                        counterOfVerticesFrontTeeth) - 1, i + counterOfVerticesFrontTeeth));
                }
                flagPutTeeth = !flagPutTeeth;
                currentAngle += incrementAngle;
            }

            //add external for the back circle
            currentAngle = 0;
            var flagPutTeeth = false;
            var externalHeightTeeth = lengthExternalTeeth;
            //remember of when my new vertices that i will add will be:
            var counterOfVerticesBackTeeth = geometry.vertices.length - 1;
            for (var i = 1; i <= numberOfTeeth * 4; i++) {

                adjustmentangle = adjustmentangle * -1;
                var externalTeethX1 = (externalRadio + externalHeightTeeth) * Math.cos(THREE.Math.degToRad(
                    currentAngle + adjustmentangle));
                var externalTeethY1 = (externalRadio + externalHeightTeeth) * Math.sin(THREE.Math.degToRad(
                    currentAngle + adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(externalTeethX1, externalTeethY1, -centerZ));

                if (i != 1 && flagPutTeeth) {
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + (i + (i - 1)), i +
                        counterOfVerticesBackTeeth, initialCounterOfVertices2 + (i + (i - 1)) - 2));
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + (i + (i - 1)) - 2, i +
                        counterOfVerticesBackTeeth, (i + counterOfVerticesBackTeeth) - 1));
                    if (yesOrNo) {
                        var centerColorMetalPurple = new THREE.MeshStandardMaterial({
                            color: 0x8000BB,
                            roughness: 0.6,
                            metalness: 0.5,
                        });
                        var holeColor = new THREE.MeshStandardMaterial({
                            color: 0x000000,
                            roughness: 0.6,
                            metalness: 0.5,
                        });
                        var gondola = new THREE.Object3D();
                        var gondolaGeometry = new THREE.CylinderGeometry(9, 7, 10);
                        var gondolaTop = new THREE.Mesh(gondolaGeometry, centerColorMetalPurple);
                        gondolaTop.position.x = externalTeethX1;
                        gondolaTop.position.y = externalTeethY1;
                        gondolaTop.position.z = -centerZ + 2;
                        gondola.add(gondolaTop);
                        /*
                        var gondolaGeometryHole = new THREE.CylinderGeometry( 8, 7, 1);
                        var gondolaTopHole = new THREE.Mesh( gondolaGeometryHole, holeColor );
                        gondolaTopHole.position.x = externalTeethX1;
                        gondolaTopHole.position.y = externalTeethY1;
                        gondolaTopHole.position.z = -centerZ +2;
                        gondola.add(gondolaTopHole);
                        gondola.position.y += 4.8;
                        */
                        gondolasGroup.add(gondola);
                    }
                }
                flagPutTeeth = !flagPutTeeth;
                currentAngle += incrementAngle;
            }

            //add unions between the external teeth (back and front):
            //on each iteration i will cover a teeth and a hole
            var flag = true;
            for (var i = 1; i <= numberOfTeeth * 2 + 1; i++) {
                if (flag) {
                    //tapa del diente
                    geometry.faces.push(new THREE.Face3(counterOfVerticesFrontTeeth + i, counterOfVerticesBackTeeth +
                        i + 1, counterOfVerticesFrontTeeth + i + 1));
                    geometry.faces.push(new THREE.Face3(counterOfVerticesBackTeeth + i, counterOfVerticesBackTeeth + i +
                        1, counterOfVerticesFrontTeeth + i));
                    if (i != 1) {
                        //tapa del hoyo
                        geometry.faces.push(new THREE.Face3(initialCounterOfVertices + (i * 2) - 1,
                            initialCounterOfVertices + (i * 2) - 3, initialCounterOfVertices2 + (i * 2) - 1));
                        geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + (i * 2) - 1,
                            initialCounterOfVertices + (i * 2) - 3, initialCounterOfVertices2 + (i * 2) - 3));
                    }
                }
                //cara izq del diente visto desde el frente (abajo)
                geometry.faces.push(new THREE.Face3(counterOfVerticesFrontTeeth + i, initialCounterOfVertices2 + (i *
                    2) - 1, initialCounterOfVertices + (i * 2) - 1));
                geometry.faces.push(new THREE.Face3(counterOfVerticesBackTeeth + i, initialCounterOfVertices2 + (i *
                    2) - 1, counterOfVerticesFrontTeeth + i));
                //cara derecha del diente vusto desde enfrente (arriba)
                geometry.faces.push(new THREE.Face3(counterOfVerticesFrontTeeth + i, initialCounterOfVertices + (i *
                    2) - 1, initialCounterOfVertices2 + (i * 2) - 1));
                geometry.faces.push(new THREE.Face3(counterOfVerticesBackTeeth + i, counterOfVerticesFrontTeeth + i,
                    initialCounterOfVertices2 + (i * 2) - 1));

                flag = !flag;
            }

            //add internal teeth to the vertices array and faces:
            currentAngle = 0;
            var flagPutTeeth = true;
            var innerHeightTeeth = innerRadio / 6;
            //remember of when my new vertices that i will add will be:

            var counterOfVerticesInnerFrontTeeth = geometry.vertices.length - 1;
            adjustmentangle = adjustmentangle * -1;
            for (var i = 1; i <= numberOfTeeth * 4; i++) {
                adjustmentangle = adjustmentangle * -1;
                var innerTeethX1 = (innerRadio - innerHeightTeeth) * Math.cos(THREE.Math.degToRad(currentAngle +
                    adjustmentangle));
                var innerTeethY1 = (innerRadio - innerHeightTeeth) * Math.sin(THREE.Math.degToRad(currentAngle +
                    adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(innerTeethX1, innerTeethY1, centerZ));
                if (i != 1 && flagPutTeeth) {
                    geometry.faces.push(new THREE.Face3(i + counterOfVerticesInnerFrontTeeth, (i +
                        counterOfVerticesInnerFrontTeeth) - 1, initialCounterOfVertices + (i * 2) - 4));
                    geometry.faces.push(new THREE.Face3(i + counterOfVerticesInnerFrontTeeth, initialCounterOfVertices +
                        (i * 2) - 4, initialCounterOfVertices + (i * 2) - 2));
                }
                flagPutTeeth = !flagPutTeeth;
                currentAngle += incrementAngle;
            }

            //internal teeth for the back

            //add internal teeth to the vertices array and faces:
            currentAngle = 0;
            var flagPutTeeth = true;
            var innerHeightTeeth = innerRadio / 6;
            //remember of when my new vertices that i will add will be:

            var counterOfVerticesInnerBackTeeth = geometry.vertices.length - 1;

            for (var i = 1; i <= numberOfTeeth * 4; i++) {
                adjustmentangle = adjustmentangle * -1;
                var innerTeethX1 = (innerRadio - innerHeightTeeth) * Math.cos(THREE.Math.degToRad(currentAngle +
                    adjustmentangle));
                var innerTeethY1 = (innerRadio - innerHeightTeeth) * Math.sin(THREE.Math.degToRad(currentAngle +
                    adjustmentangle));
                geometry.vertices.push(new THREE.Vector3(innerTeethX1, innerTeethY1, -centerZ));
                if (i != 1 && flagPutTeeth) {
                    geometry.faces.push(new THREE.Face3(i + counterOfVerticesInnerBackTeeth, initialCounterOfVertices2 +
                        (i * 2) - 4, (i + counterOfVerticesInnerBackTeeth) - 1));
                    geometry.faces.push(new THREE.Face3(i + counterOfVerticesInnerBackTeeth, initialCounterOfVertices2 +
                        (i * 2) - 2, initialCounterOfVertices2 + (i * 2) - 4));
                }
                flagPutTeeth = !flagPutTeeth;
                currentAngle += incrementAngle;
            }

            //add unions between the external teeth (back and front):
            //on each iteration i will cover a teeth and a hole
            var flag = false;
            for (var i = 1; i <= numberOfTeeth * 2 + 1; i++) {
                if (flag) {
                    //tapa del diente
                    geometry.faces.push(new THREE.Face3(counterOfVerticesInnerFrontTeeth + i,
                        counterOfVerticesInnerFrontTeeth + i + 1, counterOfVerticesInnerBackTeeth + i + 1));
                    geometry.faces.push(new THREE.Face3(counterOfVerticesInnerBackTeeth + i,
                        counterOfVerticesInnerFrontTeeth + i, counterOfVerticesInnerBackTeeth + i + 1));


                } else {
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices + (i * 2), initialCounterOfVertices2 +
                        (i * 2), initialCounterOfVertices + (i * 2) - 2));
                    geometry.faces.push(new THREE.Face3(initialCounterOfVertices2 + (i * 2), initialCounterOfVertices2 +
                        (i * 2) - 2, initialCounterOfVertices + (i * 2) - 2));
                }
                //cara izq del diente visto desde el frente (abajo)
                geometry.faces.push(new THREE.Face3(counterOfVerticesInnerFrontTeeth + i + 1,
                    initialCounterOfVertices2 + (i * 2), initialCounterOfVertices + (i * 2)));
                geometry.faces.push(new THREE.Face3(counterOfVerticesInnerBackTeeth + i, initialCounterOfVertices2 + (
                    i * 2) - 2, counterOfVerticesInnerFrontTeeth + i));
                //cara derecha del diente vusto desde enfrente (arriba)
                geometry.faces.push(new THREE.Face3(counterOfVerticesInnerFrontTeeth + i, initialCounterOfVertices + (
                    i * 2) - 2, initialCounterOfVertices2 + (i * 2) - 2));
                geometry.faces.push(new THREE.Face3(counterOfVerticesInnerBackTeeth + i,
                    counterOfVerticesInnerFrontTeeth + i, initialCounterOfVertices2 + (i * 2) - 2));

                flag = !flag;
            }


        }

        function rotateWheels() {
            pivotw1.rotation.z = THREE.Math.degToRad(wheelrot) 
            pivotw2.rotation.z = THREE.Math.degToRad(wheelrot + 180) 
            //stwheel.rotation.y = THREE.Math.degToRad(wheelrot)
        }

        function accelerationCar() {
            carOrientation -= ( acc * 0.02 ) * wheelrot/2;

            // movement of car
			car.position.x -= Math.sin( carOrientation ) * acc * 5;
			car.position.z -= Math.cos( carOrientation ) * acc * 5;

			// angle of car
			car.rotation.z = carOrientation;
            //pivotw1.rotation.z += 2*3.1416;
            //pivotw2.rotation.z +=  2*3.1416;


            //car.position.x += acc
            if (acc > 0 && acc > 0.001)
                acc -= 0.001
            else if (acc < 0 && acc < -0.001)
                acc += 0.001
            else
                acc = 0
            pivotw1.rotation.x -= acc / 2
            pivotw2.rotation.x -= acc / 2
            pivotw3.rotation.x -= acc / 2
            pivotw4.rotation.x -= acc / 2
        }


        function moveSpike() {
            if(spikeout){
                if(spike.position.y > -11)
                    spike.position.y -= 0.1
            }else if(spike.position.y < -6)
                spike.position.y += 0.1 
        }

        function shootGun() {
            if(shoot && laserready){
                shoot= false
                laserready = false    
            }
            if(laserready == false){
                laser.position.y -=100
                if(laser.position.y < -5000){
                    laser.position.y = 0
                    laserready=true
                }

            }
        }

        function moveSpoiler() {
            if(spoilerout){
                if(spoilercount < 20){
                    spoilercount+=1
                    spoiler.rotation.x = THREE.Math.degToRad(-spoilercount)
                    spoiler.position.y -= 0.1
                    spoiler.position.z -= 0.075
                }
            }else if(spoilercount>0){
                    spoilercount-=1
                    spoiler.rotation.x = THREE.Math.degToRad(2-spoilercount)
                    spoiler.position.y += 0.1
                    spoiler.position.z += 0.075
            }
                
        }
                

        function droneMovement() {
            if (dronefree) {
                if (helix.position.z < 20)
                    helix.position.z += 0.1
            } else if (helix.position.z > 0)
                helix.position.z -= 0.1
            if (helix.position.z > 0) {
                pivot1.rotation.z += 0.5
                pivot2.rotation.z += 0.5
                pivot3.rotation.z += 0.5
            }
        }
        var render = function () {
            //Do not touch
            requestAnimationFrame(render);
            rotateWheels()
            accelerationCar()
            droneMovement()
            moveSpike()
            moveSpoiler()
            shootGun()
            centerInternGear.rotation.z += velocity;
            centerGear.rotation.z += velocity;
            centerGear2.rotation.z += velocity;

            var arrayGondolas = gondolasGroup.children;

            arrayGondolas.forEach(gondola => {
                gondola.children[0].rotation.z -= velocity;
                //gondola.children[1].rotation.z -= velocity;
            });
            //velocity of the flash game:
            if (increase) {
                goDown = true
                velocity2 += 0.00007;
                if (velocity2 > 0.1) {
                    increase = false;
                }
                if (goUp) {
                    if (heightOfSpinner > 130) goUp = false;
                    heightOfSpinner += 0.1;
                    spinner.position.y = heightOfSpinner;
                }
            } else {
                goUp = true
                velocity2 -= 0.00007;
                if (velocity2 < 0.01) {
                    increase = true;
                }
                if (goDown) {
                    if (heightOfSpinner < 0) goDown = false;
                    heightOfSpinner -= 0.2;
                    spinner.position.y = heightOfSpinner;
                }
            }

            //centerGearForBall.rotation.z += velocity2;
            spinner.rotation.y += velocity2;
            carouselrot += 0.005
            if (carouselrot >= 6.2832)
                carouselrot = 0
            carousel.rotation.y = carouselrot


            if (hammerheadup) {
                if (hammerhead.position.y + carouselincrease > -7) {
                    hammerhead.position.y -= 0.05
                    hammerheadup = false
                } else hammerhead.position.y += 0.05
            } else {
                if (hammerhead.position.y - carouselincrease < -27) {
                    hammerhead.position.y += 0.05
                    hammerheadup = true
                } else hammerhead.position.y -= 0.05

            }
            if (dolphinup) {
                if (dolphin.position.y + carouselincrease > -15) {
                    dolphin.position.y -= 0.05
                    dolphinup = false
                } else dolphin.position.y += 0.05
            } else {
                if (dolphin.position.y - carouselincrease < -35) {
                    dolphin.position.y += 0.05
                    dolphinup = true
                } else dolphin.position.y -= 0.05

            }
            if (whaleup) {
                if (whale.position.y + carouselincrease > -8) {
                    whale.position.y -= 0.05
                    whaleup = false
                } else whale.position.y += 0.05
            } else {
                if (whale.position.y - carouselincrease < -28) {
                    whale.position.y += 0.05
                    whaleup = true
                } else whale.position.y -= 0.05

            }
            if (sharkup) {
                if (shark.position.y + carouselincrease > -5) {
                    shark.position.y -= 0.05
                    sharkup = false
                } else shark.position.y += 0.05
            } else {
                if (shark.position.y - carouselincrease < -25) {
                    shark.position.y += 0.05
                    sharkup = true
                } else shark.position.y -= 0.05

            }
            if (anglerup) {
                if (angler.position.y + carouselincrease > -5) {
                    angler.position.y -= 0.05
                    anglerup = false
                } else angler.position.y += 0.05
            } else {
                if (angler.position.y - carouselincrease < -25) {
                    angler.position.y += 0.05
                    anglerup = true
                } else angler.position.y -= 0.05

            }

            //console.log(shark.rotation.y + carouselrot)
            gondolasGroup.rotation.z += velocity;
            pointLight.position.x = camera.position.x;
            pointLight.position.y = camera.position.y;
            pointLight.position.z = camera.position.x;
            pointLight2.position.x = camera.position.x;
            pointLight2.position.y = camera.position.y;
            pointLight2.position.z = camera.position.z;
            zpos = (aug * Math.cos(THREE.Math.degToRad(theta)));
            xpos = (augx * Math.cos(THREE.Math.degToRad(theta)));
            camera.translateZ(zpos);
            camera.translateX(xpos);
            camera.rotation.y = theta;
            /* as passanger
            camera.position.z = car.position.z;
            camera.position.x = car.position.x;
            camera.position.y = car.position.y + 10;
            camera.rotation.y = 3.14+car.rotation.y;
            */
            aug = 0;
            augx = 0;
            renderer.render(scene, camera);
            //Ends Here
        };
        render();
    </script>
</body>

</html>